const web3 = require("web3");
const sync_blocks = require("./../common/blockchain/ETH");
const { Deposit, ETHSyncBlock } = require("../models");
const { isEmpty } = require("lodash");

global.listenAddresses = [];
global.listenTransaction = [];
global.lastSyncBlock = undefined;

const ETH_SYNC_BLOCK_DB_ID = 1;

async function init(){
	if (isEmpty(lastSyncBlock)) {
		const syncETHInfo = await ETHSyncBlock.findById(ETH_SYNC_BLOCK_DB_ID);
		if (!isEmpty(syncETHInfo)) {
			listenAddresses = syncETHInfo.listen_addresses;
			lastSyncBlock = syncETHInfo.last_block;
			listenTransaction = syncETHInfo.listen_transaction;
		}
	}
}

(function () {
	init();
})();

/**
 * Start syncing blocks and listen for new transactions on the blockchain
 */
async function start_syncing_blocks() {
	// start from the last block number processed or 0 (you can use the current block before deploying for the first time)
	if (!isEmpty(lastSyncBlock) && !isEmpty(listenAddresses)) {
		last_block_number = lastSyncBlock || 0;
		// start syncing blocks
		sync_blocks(last_block_number, {
			// for every new block update the latest block value
			onBlock: update_block_head,
			// for new transactions check each transaction and see if it's new
			onTransactions: async (transactions) => {
				for (let i in transactions) {
					await process_transaction(transactions[i]);
				}
			}
		});
	}
}

// save the lastest block
async function update_block_head(head) {
	const syncBlockInfo = await ETHSyncBlock.findOneAndUpdate({ _id: ETH_SYNC_BLOCK_DB_ID }, { last_block: head }, { upsert: true });
	if (isEmpty(syncBlockInfo)) {
		listenAddresses = syncETHInfo.listen_addresses;
		lastSyncBlock = syncETHInfo.last_block;
		listenTransaction = syncETHInfo.listen_transaction;
	}
	return syncETHInfo.last_block;
}

// process a new transaction
async function process_transaction(transaction) {
	const address = transaction.to.toLowerCase();
	const amount_in_ether = web3.utils.fromWei(transaction.value);

	// check if the receiving address has been generated by our wallet
	if (listenAddresses.indexOf(address) !== -1) {
		return false;
	}

	const newDeposit = new Deposit({
		transaction_id: transaction.hash,
		currency: "ETH",
		to: address,
		value: amount_in_ether,
	});

	await Deposit.findOneAndUpdate({ transaction_id: transaction.hash }, newDeposit, { upsert: true });

	return true;
}

module.exports = start_syncing_blocks;