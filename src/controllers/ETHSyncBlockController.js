const Web3 = require("web3");
const { Deposit, ETHSyncBlock } = require("../models");
const { isEmpty } = require("lodash");
const { constants } = require("../common/helpers/constants");

var web3 = new Web3(new Web3.providers.WebsocketProvider(process.env.NODE_ENV === "dev"?process.env.ETH_TESTNET:process.env.ETH_MAINNET));

var syncBlockInfo = undefined;

var ETHSyncBlockInfo = {
	update(newBlockInfo) {
		syncBlockInfo = newBlockInfo;
	}
};

async function initSyncBlock() {
	try {
		if (isEmpty(syncBlockInfo)) {
			syncBlockInfo = await ETHSyncBlock.findById(constants.eth.SYNC_BLOCK_INFO_ID);

			if (isEmpty(syncBlockInfo)) {
				const syncBlock = new ETHSyncBlock({
					_id: constants.eth.SYNC_BLOCK_INFO_ID,
					lastSyncedBlock: constants.eth.START_SYNC_BLOCK,
					listenAddresses: [],
					listenTransactions: []
				});
				syncBlockInfo = await ETHSyncBlock.create(syncBlock);
			}
		}
		startSyncingBlocks();
	} catch (e) {
		console.log("Error in initialize to sync Ethereum block", e.message);
	}
}

/**
 * Start syncing blocks and listen for new transactions on the blockchain
 */
async function startSyncingBlocks() {
	try {
		// start from the last block number processed or 0 (you can use the current block before deploying for the first time)
		var lastBlockNumber = syncBlockInfo.lastSyncedBlock || 0;
		// start syncing blocks
		syncBlocks(lastBlockNumber, {
			onBlock: updateBlockHead,
			onTransactions: async (transactions) => {
				for (let i in transactions) {
					await processTransaction(transactions[i]);
				}
			}
		});
	} catch (e) {
		console.log(e.message);
	}
}

// save the lastest block
async function updateBlockHead(head) {
	syncBlockInfo = await ETHSyncBlock.findOneAndUpdate({ _id: constants.eth.SYNC_BLOCK_INFO_ID }, { lastSyncedBlock: head }, { upsert: true });
	return syncBlockInfo.lastSyncedBlock;
}

// process a new transaction
async function processTransaction(transaction) {
	try {
		if (isEmpty(transaction.to)) {
			return false;
		}
		const address = transaction.to.toLowerCase();
		const amountInEther = web3.utils.fromWei(transaction.value);
		// check if the receiving address has been generated by our wallet
		if (syncBlockInfo.listenAddresses.indexOf(address) === -1) {
			return false;
		}
		const newDeposit = new Deposit({
			transactionId: transaction.hash,
			currency: "ETH",
			to: address,
			value: amountInEther,
		});

		await Deposit.create(newDeposit);

		return true;
	} catch (e) {
		console.log(e.message);
	}
}

/**
 * Sync blocks and start listening for new blocks
 * @param {Number} currentBlockNumber - The last block processed
 * @param {Object} opts - A list of options with callbacks for events
 */
async function syncBlocks(currentBlockNumber, opts) {
	// first sync the wallet to the latest block
	let latestBlockNumber = await web3.eth.getBlockNumber();
	let syncedBlockNumber = await syncToBlock(currentBlockNumber, latestBlockNumber, opts);
	// subscribe to new blocks
	web3.eth.subscribe("newBlockHeaders", (error, result) => error && console.log(error))
		.on("data", async function (blockHeader) {
			return await processBlock(blockHeader.number, opts);
		});
	return syncedBlockNumber;
}

// Load all data about the given block and call the callbacks if defined
async function processBlock(blockHashOrId, opts) {
	// load block information by id or hash
	const block = await web3.eth.getBlock(blockHashOrId, true);
	// call the onTransactions callback if defined
	opts.onTransactions && !isEmpty(block) ? opts.onTransactions(block.transactions) : null;
	// call the onBlock callback if defined
	opts.onBlock ? opts.onBlock(blockHashOrId) : null;
	return block;
}

// Traverse all unprocessed blocks between the current index and the lastest block number
async function syncToBlock(index, latest, opts) {
	if (index >= latest) {
		return index;
	}
	await processBlock(index + 1, opts);
	return await syncToBlock(index + 1, latest, opts);
}

(function () {
	initSyncBlock();
})();

module.exports = {
	initSyncBlock,
	ETHSyncBlockInfo,
	web3
};