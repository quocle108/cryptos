const Web3 = require("web3");
const SyncBlocks = require("./../common/blockchain/ETH/SyncBlocks");
const { Deposit, ETHSyncBlock } = require("../models");
const { isEmpty } = require("lodash");

web3 = new Web3(new Web3.providers.WebsocketProvider("wss://ropsten.infura.io/ws/v3/fbd88569690f478abf4e5ae1978088c9"));
Web3.providers.we
global.syncBlockInfo = undefined

const ETH_SYNC_BLOCK_DB_ID = 1;

async function initialize() {
	try {
		if (isEmpty(syncBlockInfo)) {
			syncBlockInfo = await ETHSyncBlock.findById(ETH_SYNC_BLOCK_DB_ID);

			if (isEmpty(syncBlockInfo)) {
				const syncBlock = new ETHSyncBlock({
					_id: ETH_SYNC_BLOCK_DB_ID,
					last_block: 0,
					listen_addresses: [],
					listen_transaction: []
				});
				syncBlockInfo = await ETHSyncBlock.create(syncBlock);
			}
		}
	} catch (e) {
		console.log("Error in initialize to sync Ethereum block", e.message)
	}
}

(function () {
	initialize();
	start_syncing_blocks();
	// setTimeout(function run() {
	// 	start_syncing_blocks();
	// 	setTimeout(run, 3000);
	// }, 3000);
})();

/**
 * Start syncing blocks and listen for new transactions on the blockchain
 */
async function start_syncing_blocks() {
	try {
		syncBlockInfo = await ETHSyncBlock.findById(ETH_SYNC_BLOCK_DB_ID);
		console.log("current block", syncBlockInfo.last_block)
		// start from the last block number processed or 0 (you can use the current block before deploying for the first time)
		if (!isEmpty(syncBlockInfo.listen_addresses)) {
			last_block_number = syncBlockInfo.last_block || 0;
			// start syncing blocks
			SyncBlocks.sync_blocks(last_block_number, {
				onBlock: update_block_head,
				onTransactions: async (transactions) => {
					for (let i in transactions) {
						await process_transaction(transactions[i]);
					}
				}
			});
		}
	} catch (e) {
		console.log(e.message)
	}
}

// save the lastest block
async function update_block_head(head) {
	const syncBlockInfo = await ETHSyncBlock.findOneAndUpdate({ _id: ETH_SYNC_BLOCK_DB_ID }, { last_block: head }, { upsert: true });
	return syncBlockInfo.last_block;
}

// process a new transaction
async function process_transaction(transaction) {
	try{
	if (isEmpty(transaction.to)) {
		return false;
	}
	const address = transaction.to.toLowerCase();
	const amount_in_ether = web3.utils.fromWei(transaction.value);
	// check if the receiving address has been generated by our wallet
	if (syncBlockInfo.listen_addresses.indexOf(address) === -1) {
		return false;
	}
	console.log("address123", address)
	const newDeposit = new Deposit({
		transaction_id: transaction.hash,
		currency: "ETH",
		to: address,
		value: amount_in_ether,
	});

	await Deposit.create(newDeposit);

	return true;
	}catch(e){
		console.log(e.message)
	}
}

module.exports = {
	initialize
}